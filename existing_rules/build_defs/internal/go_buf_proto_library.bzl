load(
    "@io_bazel_rules_go//go:def.bzl",
    "GoLibrary",
    "go_context",
)
load(
    "@io_bazel_rules_go//go/private/rules:transition.bzl",
    "go_reset_target",
)
load(
    "@io_bazel_rules_go//proto/wkt:well_known_types.bzl",
    "PROTO_RUNTIME_DEPS",
    "WELL_KNOWN_TYPES_APIV2",
)
load(
    "@bazel_skylib//lib:paths.bzl",
    "paths",
)


load("@io_bazel_rules_go//proto:compiler.bzl", "GoProtoCompiler")

def go_proto_compile(go, compiler, protos, imports, importpath):
    """Invokes `buf generate` to create Go sources for a given set of protos
    Args:
        go: the go object, returned by go_context.
        compiler: a GoProtoCompiler provider.
        protos: list of ProtoInfo providers for protos to compile.
        imports: depset of strings mapping proto import paths to Go import paths.
        importpath: the import path of the Go library being generated.
    Returns:
        A list of .go files generated by Buf.
    """

    proto_srcs = []
    go_srcs = []
    outpath = None
    proto_paths = {}
    desc_sets = []
    for proto in protos:
        desc_sets.append(proto.transitive_descriptor_sets)
        proto_srcs.append(proto.check_deps_sources)
        for src in proto.check_deps_sources.to_list():
            path = proto_path(src, proto)
            if path in proto_paths:
                if proto_paths[path] != src:
                    fail("proto files {} and {} have the same import path, {}".format(
                        src.path,
                        proto_paths[path].path,
                        path,
                    ))
                continue
            proto_paths[path] = src

            out = go.declare_file(
                go,
                path = importpath + "/" + src.basename[:-len(".proto")],
                ext = compiler.internal.suffix,
            )
            go_srcs.append(out)
            if outpath == None:
                outpath = out.dirname[:-len(importpath)]

    transitive_descriptor_sets = depset(direct = [], transitive = desc_sets)
    transitive_proto_srcs = depset(direct = [], transitive = proto_srcs)

    args = go.actions.args()

    gooutpath = go_srcs[0].path
    gooutpath = gooutpath[:gooutpath.rfind("/")]
    gooutpath = gooutpath[:gooutpath.rfind("/")]

    args.add("generate")
    args.add_all(proto_paths.keys(), before_each = "--path")
    args.add("--template", """{"version":"v1","plugins":[{"name":"go","out":"%s","path":"%s","opt":"paths=source_relative"}]}""" % (gooutpath, compiler.internal.plugin.path))

    if compiler.internal.import_path_option:
        args.add_all([importpath], before_each = "-option", format_each = "import_path=%s")

    go.actions.run(
        inputs = depset(
            direct = [
                compiler.internal.buf,
                compiler.internal.plugin,
            ],
            transitive = [transitive_proto_srcs],
        ),
        outputs = go_srcs,
        progress_message = "Generating into %s" % go_srcs[0].dirname,
        mnemonic = "BufGenerateGo",
        executable = compiler.internal.buf,
        arguments = [args],
        env = go.env,
        # We may need the shell environment (potentially augmented with --action_env)
        # to invoke protoc on Windows. If protoc was built with mingw, it probably needs
        # .dll files in non-default locations that must be in PATH. The target configuration
        # may not have a C compiler, so we have no idea what PATH should be.
        use_default_shell_env = "PATH" not in go.env,
    )
    return go_srcs

def proto_path(src, proto):
    """proto_path returns the string used to import the proto. This is the proto
    source path within its repository, adjusted by import_prefix and
    strip_import_prefix.
    Args:
        src: the proto source File.
        proto: the ProtoInfo provider.
    Returns:
        An import path string.
    """
    if not hasattr(proto, "proto_source_root"):
        # Legacy path. Remove when Bazel minimum version >= 0.21.0.
        path = src.path
        root = src.root.path
        ws = src.owner.workspace_root
        if path.startswith(root):
            path = path[len(root):]
        if path.startswith("/"):
            path = path[1:]
        if path.startswith(ws):
            path = path[len(ws):]
        if path.startswith("/"):
            path = path[1:]
        return path

    if proto.proto_source_root == ".":
        # true if proto sources were generated
        prefix = src.root.path + "/"
    elif proto.proto_source_root.startswith(src.root.path):
        # sometimes true when import paths are adjusted with import_prefix
        prefix = proto.proto_source_root + "/"
    else:
        # usually true when paths are not adjusted
        prefix = paths.join(src.root.path, proto.proto_source_root) + "/"
    if not src.path.startswith(prefix):
        # sometimes true when importing multiple adjusted protos
        return src.path
    return src.path[len(prefix):]

def _go_proto_compiler_impl(ctx):
    go = go_context(ctx)
    library = go.new_library(go)
    source = go.library_to_source(go, ctx.attr, library, ctx.coverage_instrumented())
    return [
        GoProtoCompiler(
            deps = ctx.attr.deps,
            compile = go_proto_compile,
            valid_archive = ctx.attr.valid_archive,
            internal = struct(
                options = ctx.attr.options,
                suffix = ctx.attr.suffix,
                buf = ctx.executable._buf,
                plugin = ctx.executable.plugin,
                import_path_option = ctx.attr.import_path_option,
            ),
        ),
        library,
        source,
    ]

_go_proto_compiler = rule(
    implementation = _go_proto_compiler_impl,
    attrs = {
        "deps": attr.label_list(providers = [GoLibrary]),
        "options": attr.string_list(),
        "suffix": attr.string(default = ".pb.go"),
        "valid_archive": attr.bool(default = True),
        "import_path_option": attr.bool(default = False),
        "plugin": attr.label(
            executable = True,
            cfg = "exec",
            mandatory = True,
        ),
        "_buf": attr.label(
            executable = True,
            cfg = "exec",
            default = "@buf_linux_x86_64//file",
        ),
        "_go_context_data": attr.label(
            default = "@io_bazel_rules_go//:go_context_data",
        ),
    },
    toolchains = ["@io_bazel_rules_go//go:toolchain"],
)

def buf_go_proto_compiler(name, **kwargs):
    plugin = kwargs.pop("plugin", "@com_github_golang_protobuf//protoc-gen-go")
    deps = kwargs.pop("deps", []) + PROTO_RUNTIME_DEPS + WELL_KNOWN_TYPES_APIV2
    reset_plugin_name = name + "_reset_plugin_"
    go_reset_target(
        name = reset_plugin_name,
        dep = plugin,
        visibility = ["//visibility:private"],
    )
    _go_proto_compiler(
        name = name,
        deps = deps,
        plugin = reset_plugin_name,
        **kwargs
    )
